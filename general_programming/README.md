## Contents

- [Contents](#contents)
- [変数と可変性](#変数と可変性)
  - [変数と定数](#変数と定数)
  - [シャドーイング](#シャドーイング)
    - [メリット](#メリット)
- [データ型](#データ型)
  - [スカラー型](#スカラー型)
  - [複合型](#複合型)
- [関数](#関数)
- [制御フロー](#制御フロー)
  - [if](#if)
  - [ループ](#ループ)

## 変数と可変性

基本immutable

``mut``をつけると可変になる

### 変数と定数

- 定数と不変変数は別物
- ``let``の変わりに``const``を使う(TSやDartと一緒だ)
- ``const``を使うときはデータ型の注釈が必須
- 定数の命名規則は``UPPER_SNAKE_CASE``

### シャドーイング

- 一度宣言した不変変数に再度``let``をつけて宣言すると値に加工ができる

#### メリット

```rust
// OK 
// 変数を再度宣言しているからデータ型が変わってもエラーにならない
let spaces = "    ";
let spaces = spaces.len();

// NG
// 一度目に宣言したデータ型のままであるので文字列に数値を入れることになりエラー
let mut spaces = "   ";
spaces = spaces.len();
```

## データ型

### スカラー型

- 整数
  - i or u (符号 あり or なし)
  - i32の32はビット数
    - 8, 16, 32, 64がある
- 整数リテラル
  - ``_``をつけて見た目の区切り記号とすることができる
    - ``1_000``的な
  - 16進数``0xff``
  - 8進数``0o77``
  - 2進数``0b1111_0000``
  - バイト``b'A'``
- 浮動小数点型
  - ``f32``と``f64``
  - 基本型は``f64``
  - 単精度(``f32``)
    - 1bit 正負
    - 8bit 指数部(2の何乗)
    - 23bit 仮数部(2進数で表したときの各桁の01)
  - 倍精度(``f64``)
    - 1bit 正負
    - 11bit 指数部
    - 52bit 仮数部
- 論理値(bool)
- 文字型(char)

### 複合型

- タプル
- 配列

配列の末尾を超えるような値にアクセスするとエラーでる(コンパイル時はエラーなし)
Rustでの安全機構の例

## 関数

- 命名規則は``snake_case``
- 仮引数はデータ型の指定が必要
- Rustでは代入値を返さない
  - 例えば、Cなら``x = y = 6;``と書いて、``x``と``y``に``6``が代入される
  - 一方でRustでは``let x = (let y = 6);``であるとエラーになる
- 返り値の宣言は``() -> i32 {}``のように書く
- ``;``をつけなければそれが返り値となる

## 制御フロー

### if

- Rustでは条件式に必ず論理値を与えないといけない

### ループ

- ``loop``での繰り返し
  - ``breack``と``continue``を使って制御
- ``while``でのループ
- ``for``でコレクションを抽出
  - ``for index in arr``みたいな書き方
  - ``for number in 1..4``これで1~3で回せる
